% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa_001_GenericFunctions.R,
%   R/aaa_089_class_roCache_0.89.0.R
\name{storeCache}
\alias{storeCache}
\alias{storeCache,roCache_0.89.0-method}
\alias{storeCache.roCache_0.89.0}
\title{storeCache}
\usage{
storeCache(cacheHandle, ..., id, funcHandle, returnType)

\S4method{storeCache}{roCache_0.89.0}(
  cacheHandle,
  ...,
  id,
  funcHandle = defaultFuncHandle,
  returnType = c("outputDigest", "contents", "inputDigests", "filename")
)
}
\arguments{
\item{cacheHandle}{The handle of interest.}

\item{...}{additional arguments for the funcHandle.}

\item{id}{name tag.}

\item{funcHandle}{a reference to a function. See details.}

\item{returnType}{One of 'outputDigest', 'contents', 'inputDigests', 'filename'.}
}
\description{
Stores data (as returned by funcHandle) in cache. If the fileID was already
written previously, then by default, the cache will not be changed. This will be
the case, even if the fileID is not present in cFolder, but only has an dFile
entry. Cache will only be overwritten if the handler overwrite status is explicity
set to TRUE (see \code{\link{overwrite}}). Then a change in the input parameters,
will trigger a rerun of the funcHandle, and subsequent overwriting of existing cache.
}
\details{
A function handle must be a function with a first argument being 'getDigest'
receiving either TRUE, or FALSE. If TRUE, the function must return a named
list containing digests values per named item. Usually each item reflects the
contents of an input parameter. If FALSE, the function can
can process what is was intended for, and return the result, which will be
stored in cache. (see \code{\link{defaultFuncHandle}})
}
\examples{
#Define a function handle, usable in conjuction with \code{\link{storeCache}}.
myFuncHdl<- function( getDigests, arg1, arg2) {
  #Make sure to load required libraries inside the function
  library(digest) 
  if (getDigests==TRUE) {
    #Create the input digests
    return( list(
      "arg1" = digest(arg1),
      "arg2" = digest(arg2)
   ))
  }
  #Perform the intended (heavy) processing
  result = arg1*arg2
  Sys.sleep(4)  ##Artificially sleep to mimic 'long' running function
  return(result) ##And return what should be cached
}

#Create a temporary digest file and cache folder
dFile   = tempfile() 
cFolder = tempfile() 

#Initialize cache at a non standard location
cacheHdl = initCache(dFile = dFile, cFolder = cFolder)

#Store some data in cache using the default function handler:
storeCache(cacheHdl, id = "ID1", object="This is cached")

#Store some data in cache which is generated within the funcHandle defined above. 
storeCache(cacheHdl, id = "ID2", funcHandle = myFuncHdl, arg1 = 89, arg2=10)

#Store new file with ID2, and return contents
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 2, arg2=4, returnType="contents")
#Rerun cache file with ID3, without changing input arguments. Because input arguments have not 
## changed, the funcHandle will not be rerun, and thus stored cache is not affected.  
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 2, arg2=4)
\dontrun{
#Rerun cache file with ID3, but now with a change in input arguments. Because by default 
## the handler does not allow overwriting cache, the storage is rejected. 
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 20, arg2=4)
}
#Instead allow overwriting on the cache handler:
overwrite(cacheHdl) <- TRUE
storeCache(cacheHdl, id = "ID3",  funcHandle = myFuncHdl, arg1 = 20, arg2=4)

#List fileIDs currently stored in cache
listCache(cacheHdl)

#Read the contents of a file stored in cache
readCache(cacheHdl, id="ID1", returnType = "contents")

#Remove a specific fileID
removeCache(cacheHdl, ids="ID1")

#Synchronize cFolder with dFile. Usually they are already synchronized
synchronizeCache(cacheHdl, what = "cFolder")
#However to illustrate synchronization, we can forcefully remove a file in cFolder
unlink(dir(cFolder(cacheHdl), pattern='ID2', full.names=TRUE))
#And show a dry-run
synchronizeCache(cacheHdl, what = "dFile")
#Or reinitialize the cache with syncAllowed.
cacheHdl = initCache(dFile = dFile, cFolder = cFolder, syncAllowed=TRUE)
#And perform a true run:
synchronizeCache(cacheHdl, what = "dFile")

#Clean up example
unlink(dFile(cacheHdl))
unlink(cFolder(cacheHdl), recursive=TRUE)

}
\seealso{
\code{\link{initCache}}, \code{\link{storeCache}}, \code{\link{listCache}}, \code{\link{readCache}}, \code{\link{removeCache}} , \code{\link{synchronizeCache}},\code{\link{defaultFuncHandle}}
}
