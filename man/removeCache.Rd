% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa_001_GenericFunctions.R,
%   R/aaa_089_class_roCache_0.89.0.R
\name{removeCache}
\alias{removeCache}
\alias{removeCache,roCache_0.89.0-method}
\alias{removeCache.roCache_0.89.0}
\title{removeCache}
\usage{
removeCache(cacheHandle, ids, ...)

\S4method{removeCache}{roCache_0.89.0}(cacheHandle, ids, ...)
}
\arguments{
\item{cacheHandle}{The handle of interest.}

\item{ids}{name tag to remove.}

\item{...}{not used.}
}
\description{
Removes data from cache.
}
\examples{
#Define a function handle, usable in conjuction with \code{\link{storeCache}}.
myFuncHdl<- function( getDigests, arg1, arg2) {
  #Make sure to load required libraries inside the function
  library(digest) 
  if (getDigests==TRUE) {
    #Create the input digests
    return( list(
      "arg1" = digest(arg1),
      "arg2" = digest(arg2)
   ))
  }
  #Perform the intended (heavy) processing
  result = arg1*arg2
  Sys.sleep(4)  ##Artificially sleep to mimic 'long' running function
  return(result) ##And return what should be cached
}

#Create a temporary digest file and cache folder
dFile   = tempfile() 
cFolder = tempfile() 

#Initialize cache at a non standard location
cacheHdl = initCache(dFile = dFile, cFolder = cFolder)

#Store some data in cache using the default function handler:
storeCache(cacheHdl, id = "ID1", object="This is cached")

#Store some data in cache which is generated within the funcHandle defined above. 
storeCache(cacheHdl, id = "ID2", funcHandle = myFuncHdl, arg1 = 89, arg2=10)

#Store new file with ID2, and return contents
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 2, arg2=4, returnType="contents")
#Rerun cache file with ID3, without changing input arguments. Because input arguments have not 
## changed, the funcHandle will not be rerun, and thus stored cache is not affected.  
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 2, arg2=4)
\dontrun{
#Rerun cache file with ID3, but now with a change in input arguments. Because by default 
## the handler does not allow overwriting cache, the storage is rejected. 
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 20, arg2=4)
}
#Instead allow overwriting on the cache handler:
overwrite(cacheHdl) <- TRUE
storeCache(cacheHdl, id = "ID3",  funcHandle = myFuncHdl, arg1 = 20, arg2=4)

#List fileIDs currently stored in cache
listCache(cacheHdl)

#Read the contents of a file stored in cache
readCache(cacheHdl, id="ID1", returnType = "contents")

#Remove a specific fileID
removeCache(cacheHdl, ids="ID1")

#Synchronize cFolder with dFile. Usually they are already synchronized
synchronizeCache(cacheHdl, what = "cFolder")
#However to illustrate synchronization, we can forcefully remove a file in cFolder
unlink(dir(cFolder(cacheHdl), pattern='ID2', full.names=TRUE))
#And show a dry-run
synchronizeCache(cacheHdl, what = "dFile")
#Or reinitialize the cache with syncAllowed.
cacheHdl = initCache(dFile = dFile, cFolder = cFolder, syncAllowed=TRUE)
#And perform a true run:
synchronizeCache(cacheHdl, what = "dFile")

#Clean up example
unlink(dFile(cacheHdl))
unlink(cFolder(cacheHdl), recursive=TRUE)

}
\seealso{
\code{\link{initCache}}, \code{\link{storeCache}}, \code{\link{listCache}}, \code{\link{readCache}}, \code{\link{removeCache}} , \code{\link{synchronizeCache}},\code{\link{defaultFuncHandle}}
}
