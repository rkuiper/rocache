% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/initCache.R
\name{initCache}
\alias{initCache}
\title{initCache}
\usage{
initCache(
  dFile = "./dFile.rds",
  cFolder = "./cache",
  overwrite = FALSE,
  syncAllowed = FALSE
)
}
\arguments{
\item{dFile}{path to dFile. Will be created if not existing.}

\item{cFolder}{path to cFolder. Will be created if not existing.}

\item{overwrite}{Overwrite cache upon change (default: FALSE)}

\item{syncAllowed}{Allow synchronization of cFolder (defult: FALSE).}
}
\description{
Initialize an cache handler.
}
\details{
A cache handler has an digest file (dFile) and a cache folder (cFolder).
All meta data (i.e. input/output digests) are stored in the dFile with an
entry per filename ID. The actual data is stored in the cFolder, named by
by the merger of id tag and global input digest of the stored object.
}
\examples{
#Define a function handle, usable in conjuction with \code{\link{storeCache}}.
myFuncHdl<- function( getDigests, arg1, arg2) {
  #Make sure to load required libraries inside the function
  library(digest) 
  if (getDigests==TRUE) {
    #Create the input digests
    return( list(
      "arg1" = digest(arg1),
      "arg2" = digest(arg2)
   ))
  }
  #Perform the intended (heavy) processing
  result = arg1*arg2
  Sys.sleep(4)  ##Artificially sleep to mimic 'long' running function
  return(result) ##And return what should be cached
}

#Create a temporary digest file and cache folder
dFile   = tempfile() 
cFolder = tempfile() 

#Initialize cache at a non standard location
cacheHdl = initCache(dFile = dFile, cFolder = cFolder)

#Store some data in cache using the default function handler:
storeCache(cacheHdl, id = "ID1", object="This is cached")

#Store some data in cache which is generated within the funcHandle defined above. 
storeCache(cacheHdl, id = "ID2", funcHandle = myFuncHdl, arg1 = 89, arg2=10)

#Store new file with ID2, and return contents
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 2, arg2=4, returnType="contents")
#Rerun cache file with ID3, without changing input arguments. Because input arguments have not 
## changed, the funcHandle will not be rerun, and thus stored cache is not affected.  
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 2, arg2=4)
\dontrun{
#Rerun cache file with ID3, but now with a change in input arguments. Because by default 
## the handler does not allow overwriting cache, the storage is rejected. 
storeCache(cacheHdl, id = "ID3", funcHandle = myFuncHdl, arg1 = 20, arg2=4)
}
#Instead allow overwriting on the cache handler:
overwrite(cacheHdl) <- TRUE
storeCache(cacheHdl, id = "ID3",  funcHandle = myFuncHdl, arg1 = 20, arg2=4)

#List fileIDs currently stored in cache
listCache(cacheHdl)

#Read the contents of a file stored in cache
readCache(cacheHdl, id="ID1", returnType = "contents")

#Remove a specific fileID
removeCache(cacheHdl, ids="ID1")

#Synchronize cFolder with dFile. Usually they are already synchronized
synchronizeCache(cacheHdl, what = "cFolder")
#However to illustrate synchronization, we can forcefully remove a file in cFolder
unlink(dir(cFolder(cacheHdl), pattern='ID2', full.names=TRUE))
#And show a dry-run
synchronizeCache(cacheHdl, what = "dFile")
#Or reinitialize the cache with syncAllowed.
cacheHdl = initCache(dFile = dFile, cFolder = cFolder, syncAllowed=TRUE)
#And perform a true run:
synchronizeCache(cacheHdl, what = "dFile")

#Clean up example
unlink(dFile(cacheHdl))
unlink(cFolder(cacheHdl), recursive=TRUE)

}
\seealso{
\code{\link{initCache}}, \code{\link{storeCache}}, \code{\link{listCache}}, \code{\link{readCache}}, \code{\link{removeCache}} , \code{\link{synchronizeCache}},\code{\link{defaultFuncHandle}}
}
